<1장>
-컴파일언어 : 코드 여러 개를 하나로 묶어 컴파일한 후에 실행
-인터프리터언어 : 코드를 한 줄마다 번역해서 실행 

*자바스크립트는 인터프리터 언어이다.
*자바스크립트의 모든 객체는 프로토타입이라는 객체를 가진다. 객체들은 프로토타입으로부터 프로퍼티와 메소드를 상속받는다. 
*자바스크립트는 동적 타입 언어이다. [변수의 타입이 따로 없어 모든 타입의 데이터를 저장할 수 있고, 프로그램이 실행되는 도중에 변수에 저장된 데이터 타입이 바뀔 수 있다.]
*자바스크립트에서 함수는 일급 객체이다. [함수는 변수에 할당될 수 있다. 함수는 다른 함수를 인자로 전달받을 수 있다. 함수는 다른 함수의 결과로 리턴될 수 있다. 자바스크립트로 고차함수를 구현할 수 있다.]
#일급 객체 : 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체.
#고차함수 : 함수를 전달인자(전달인자로 받는 함수 : 콜백함수) 또는 매개변수로 받거나 함수를 리턴하는 함수. 
*자바스크립트에서는 함수가 클로저를 정의한다. 
#클로저 : 자신이 생성될 때의 스코프를 기억해서 그 밖에서 호출되어도 그 스코프에 접근할 수 있는 함수. 

<2장>
*자바스크립트에서 대소문자는 구별된다. 
- 토큰으로 프로그램 분해(어휘분석) -- 구문분석(파싱)
*토큰 : 의미를 가지는 최소한의 문자 덩어리 
* ;를 이용해서 한 문장을 끝맺음.
* {}를 이용해서 문장 여러 개를 묶음. -- 복합문,블록문
* ;만 쓰면 빈문장.
*주석 : //블라블라 또는 /* 블라블라 */

<3장>
*변수 선언 : 선언자 var을 사용 [예) var sum;   var sum,a; ]
*변수 이름(식별자)  
: 1) 알파벳,숫자,밑줄(_),$만 사용가능(한글이나 한자도 가능해짐) 
  2) 첫 글자로 숫자는 올 수 없다. 
  3) 예약어는 사용할 수 없다. 
  4) 미리 정의된 전역 변수와 전역 함수는 사용할 수 없다.
*변수에 값 대입 : 예) sum = 5;
*변수 선언과 동시에 초깃값 설정 : 예) var sum = 5;   var a = 4, b = 3;
*반드시 변수를 선언하고 값을 대입할 것!
*변수 선언의 끌어올림(hoistiong) 
: 변수를 중간에 선언해도 오류가 나지 않는다. 단, 대입부는 끌어올려지지 않는다.
-- 그래도 변수는 선언해주고 사용할 것! 
*데이터 타입
: 1) 원시타입 – 숫자, 문자열, 논리값, 특수한 값, symbol (불변)
 2) 객체타입 – 원시타입이 아닌 것들, 참조 타입(변수에 객체를 대입하면 변수는 객체의 참조를 할당 받는다.)
*symbol 
: 심볼은 충돌 위험이 없는 오브젝트의 유일한 프로퍼티 키를 만들기 위해 사용할 수 있다. 하위호환성을 유지하면서 표준을 확장한다든지, 고유한 상수값을 만드는 데 사용할 수 있다. 
- 유일무이한 값, 원시타입 
- Symbol()을 사용해서 생성, 호출할 때마다 새로운 값 생성. 
- Symbol(설명) 
- Symbol.for()을 사용해서 문자열과 심볼을 연결할 수 있다. 전역 레지스트리에 해당 심볼이 만들어지고, 전역 레지스트리에서 연결된 문자열로 심볼을 불러올 수 있다. 
- Symbol.keyFor()로 연결된 문자열을 구할 수 있다. 
*템플릿 리터럴 
: 문자열의 일부를 변경해서 재사용할 수 있는 틀. 
*보간 표현식 
: 플레이스 홀더($[  ])를 사용하여 문자열 안에 변수나 표현식의 결괏값을 삽입.

<4장>
*객체 : 데이터(이름과 값)를 여러 개 모은 복합 데이터
- 프로퍼티 : 이름과 값의 한 쌍 
*객체 리터럴로 객체 생성하기 
예) var card = { suit:“하트”, rank:“A”};  var card = { “suit”:“하트”, “rank”:“A”};
- {  } 부분이 객체 리터럴
*객체 리터럴에서 프로퍼티의 값 읽기 
card.suit -> 하트   : 마침표 사용 시에는 문자열로된 프로퍼티 이름 사용 불가.  
card[“rank”] -> A  : 대괄호 사용 시에는 문자열로된 프로퍼티 이름 사용. 
*프로퍼티 추가하기 
: 기존에 포함되지 않았던 프로퍼티의 이름에 값을 대입한다. 예) card.value = 14;
*프로퍼티 삭제하기 
: 예) delete card.rank;  -> rank 키와 값이 객체에서 삭제된다. 
*프로퍼티의 존재 여부 확인하기 
: 프로퍼티의 이름을 뜻하는 ‘문자열’ in 객체명 
*객체의 프로퍼티 값으로 객체를 대입할 수도 있다. 
*프로퍼티의 값이 함수인 경우 그 프로퍼티는 메소드이다. 
*변수에 객체를 대입한다. = 객체의 참조가 변수에 저장된다. 
*객체의 참조는 또 다른 변수에도 저장될 수 있다. -> 또 다른 변수를 통해서도 객체에 접근할 수 있다. 

*생성자로 객체 생성하기 
*생성자는 이름은 같지만 값이 다른 메서드와 프로퍼티를 가진 객체를 여러 개 만들 수 있다. 
*생성자로 객체를 생성할 때는 new 연산자를 사용한다. 
*자바스크립트에는 내장 생성자가 있다. 
예) function Card(suit,rank) {
	this.suit = suit;
	this.rank = rank;
   }

var card = new Card(“하트”,“A”);
---> suit라는 이름의 프로퍼티에 “하트”라는 값이 할당된, rank라는 이름의 프로퍼티에 “A”라는 값이 할당된 객체(인스턴스)가 생성된다. 
- 값이 함수이면 메소드가 생성된다. 


*함수 선언문으로 함수 정의하기 
: 예) function square(x) { return x*x; } -- x는 인수, { } 안은 함수가 실행하는 코드
*함수 호출 : 예) square(3)
*자바스크립트에서는 함수도 끌어올려진다. 
*함수는 객체이다. 함수를 선언하면 함수의 이름이 변수가 되고 그 변수에 함수 객체의 참조가 저장된다. 
*참조에 의한 호출 vs 값에 의한 호출 
- 값에 의한 호출 : 변수(인수)의 복사본이 인자에 전달됨. 이때 복사본은 값 자체. 따라서 인자를 통해 변수의 값을 바꿀 수 없다. 
- 참조에 의한 호출 : 변수(인수)의 복사본이 인자에 전달됨. 이때 복사본은 객체의 참조 값. 인자는 변수와 같은 객체를 참조하게 되므로 인자를 통해 변수의 값을 바꿀 수 있다. 
*함수에 전달하는 인수가 여러 개인 경우 
: 인수를 프로퍼티에 담아서 하나의 객체로 만든다. 
*함수 안에서도 변수 선언부는 끌어올려진다. 
*함수 안에서 변수를 선언하지 않고 값을 대입하면 그 변수는 자동으로 전역변수가 된다. 
*let 
: 블록 유효 범위{ }를 갖는 지역 변수를 선언한다. 블록 유효 범위 밖에서 블록 유효 범위를 갖는 지역 변수를 선언하면 참조 오류가 발생한다. let으로 선언한 변수도 끌어올려지긴 하지만 var로 선언한 변수와 달리 undefined로 초기화되지 않기 때문에 let으로 변수를 선언하기 전에 사용하면 참조 오류가 발생한다. let으로는 동일한 이름의 변수를 선언할 수 없다. 
- 형식 : 예) let x;   let x=5;  let x,y;  
*const 
: 블록 유효 범위를 가지면서 한 번만 할당할 수 있는 변수(상수)를 선언한다. 반드시 초기값을 지정해줘야 한다. 예) const c = 1; 
const로 한 번 선언한 변수에 또 다른 값을 대입하면 타입 오류가 발생한다. const로 선언한 상수 값은 수정할 수 없지만, 만약 상수 값이 객체이거나 배열인 경우에는 프로퍼티 또는 프로퍼티 값을 수정할 수 있다. 
*함수 리터럴로 함수 정의하기 
function square(x) { return x*x; }   -----> var square = function(x) { return x*x; };
                                                               이름이 없는 함수
- 익명함수는 변수에 할당되어야 비로소 변수와 같은 이름을 갖게 된다. 따라서 함수 리터럴로 정의한 함수는 끌어올려지지 않는다. 선언문으로 정의한 함수는 끌어올려진다. 
*메서드 실행 형식 : 예) 변수 이름.메서드 이름()
*전역 객체 : 프로그램의 어디서나 사용할 수 있는 객체.
*자바스크립트에서 객체의 종류 
- 네이티브 객체 : ECMAScript 사양에 정의되어 있는 객체 [내장 생성자로 생성된 객체, 내장 객체]
- 호스트 객체 : ECMAScript 사양에 정의되어 있지는 않지만 자바스크립트 실행 환경에 정의된 객체
- 사용자 정의 객체 : 사용자가 정의한 코드의 결과로 인해 생성되는 객체 
*배열 : 값의 목록(배열도 객체)
*배열 리터럴로 배열 생성하기
예) var evens = [2,4,6,8];
                배열리터럴
- 배열 요소는 왼쪽부터 0,1,2... 인덱스를 가진다. 
- 배열 요소는 모든 타입의 데이터가 올 수 있다. 
- evens[2] --> 배열에서 인덱스가 2인 6을 반환. 이때 인덱스값은 문자열 형식이어도 됨.
*array 생성자로 배열 생성하기 
예) var evens = new Array(2,4,6,8); -- 배열 [2,4,6,8] 생성
 var evens = new Array(2) -- array의 인수가 양의 정수 한 개이면 그 길이의 배열 생성.
                               array의 인수가 양의 정수가 아닌 거 한 개이면 오류.
*length 프로퍼티 값 = 배열 길이 
예) 변수 이름.length  ---> 배열 길이 
  변수 이름.length = 값 ---> 1) 0 < 값(정수) < 배열 길이 — 값의 크기만큼으로 배열 축소
                             2) 값(정수) > 배열 길이 — length 프로퍼티의 값만 바뀜
*배열 요소의 추가 
예) var a = [1,2,3];
   a[3] = 4;
   a.push(5); -- push를 사용하면 배열의 맨 끝에 요소를 추가할 수 있다. 
*배열 요소의 삭제 
예) delete a[1]; -- 인덱스값에 해당하는 요소가 삭제된다. 단, 배열의 길이는 유지.
*희소 배열 : 배열 요소의 위치가 연속적이지 않은 배열.
- 희소 배열의 길이 > 배열 요소의 개수

<5장>
*산술 연산자
- 산술 이항 연산자
- 산술 다항 연산자 : 전위 표기법이냐 후위 표기법이냐에 따라 피연산자가 평가되는 시점이 달라진다. 
- 산술 대입 연산자 
*숫자에 유효한 자릿수가 있어 산술 연산 시에 오차가 발생한다. 
*자바스크립트에서는 문자열이 아닌 객체도 문자열로 반환이 가능하다면 문자열로 바뀌어서 +연산자를 통해 연결된다. 
*문자열 리터럴로 생성한 문자열의 타입 — 문자열
 String 생성자로 생성한 문자열(배열처럼 인덱스값을 가진다.)의 타입 — 객체 
*wrapping : 원시 값을 객체로 변환하는 행위 
*래퍼 객체 : 원시 값이 일시적으로 변환되는 객체 
- 래퍼 객체 덕분에 문자열을 String 객체로 변환하지 않아도 String의 메서드와 프로퍼티를 사용할 수 있다. 
*논리 연산자 
- && : and 
- || : or
- ! : not 
*관계 연산자가 논리 연산자보다 우선 순위가 높다. 
*논리곱 연산자(&&)와 논리합 연산자(||)는 단락 평가를 한다. 단락평가란 첫 번째 피연산자 값이 표현식을 결정하면 두 번째 피연산자를 평가하지 않는 것을 말한다. 단락평가 후에는 논리값이 아닌 마지막으로 평가된 피연산자의 값이 반환된다. 
*비트 연산자 
- 비트 논리 연산자
: 1 = true, 0 = false 
&-비트논리곱(and), |-비트논리합(or), ^-배타적논리합, ~-비트논리부정(not)
*비트 시프트 연산자 : 정수를 2진수 비트 단위로 오른쪽이나 왼쪽으로 이동시키는 연산자.
                     좌변의 값을 우변의 값만큼 이동시킨다.
<< - 왼쪽 시프트, 넘치는 건 버리고 비워진 건 0으로 채운다.
>> - 부호 있는 오른쪽 시프트, 넘치는 건 버리고 비워진 건 피연산자의 부호 비트로 채운다. 
>>> - 부호 없는 오른쪽 시프트, 넘치는 건 버리고 비워진 건 0으로 채운다. 
*기타 연산자 
- typeof 연산자 : 피연산자의 데이터 타입을 알려준다. 
- 조건 연산자 : 자바스크립트에서 세 개의 피연산자를 받는 유일한 연산자(삼항 연산자). 
if ~ else문의 대체재로 자주 사용된다.  
- 쉼표 연산자 : 각각의 피연산자를 왼쪽에서 오른쪽으로 평가하고, 마지막 연산자의 값을 반환한다. for문에서 자주 사용된다. 
*명시적 타입 변환 
- 숫자 --> 문자열 
: 1) + 연산자로 숫자와 문자열을 연결하면 숫자의 타입이 문자열로 바뀐다.
  2) Number 객체의 메서드 사용 
  3) String 함수 사용(String 함수는 모든 데이터 타입을 문자열로 바꾼다.) 
     형식 : String(데이터)


- 문자열 --> 숫자 
: 1) 수식 안에서 묵시적으로 변환하기 
예) var s = “2”;
   s – 0 또는 +s 사용
2) parseInt 함수 또는 parseFloat 함수 사용하기 
parseInt : 문자열을 해석해서 정수로 변환, 두 번째 인수에 2에서 36 사이의 값을 넣어 몇 진수로 해석해서 변환할지 결정. 예) parseInt(“101”,2) -- 2진수로 해석해서 변환 
parseFloat : 문자열을 해석해서 부동소수점으로 변환 
두 함수 모두 첫 번째 문자만 숫자로 변환하고 뒤에 나오는 문자열은 무시한다. 문자를 숫자로 바꿀 수 없으면 NaN을 반환한다. 문자열 앞 부분이 0x나 0X로 시작하면 16진수로 해석한다. 문자열 앞 공백은 무시된다. 
3) Number 함수 사용하기 : 10진수만 처리 가능. 모든 데이터의 타입을 숫자로 변환.

- 논리값으로 변환하기 
방법 1) !! 값
방법 2) Boolean(값)

<6장>
*window 객체의 대화상자(모달 창:사용자의 이목을 집중시키기 위한 그래픽 인터페이스 창) 표시 메서드 
1) alert: 경고 대화상자
2) prompt : 사용자의 문자열 입력을 받는 대화상자, 문자열 반환.
3) confirm : 확인버튼과 취소버튼이 있는 대화상자, 논리값 반환. (확인=true, 취소=false)
*console.dir 메서드 : 객체의 프로퍼티를 나열한다. 
*이벤트 주도형 프로그램 : 이벤트 처리기(이벤트 발생 시 실행되는 함수)를 미리 등록해두고 이벤트가 발생하면 실행시킨다. 
*함수를 이벤트의 이벤트 처리기로 설정하기 
1) HTML 요소의 속성에 등록하기 
- 이벤트 처리기의 이름 = 이벤트의 유형 
2) DOM에서 가져온 HTML 요소에 이벤트 처리기 지정하기 
- DOM 객체 : window/document/요소 객체
*타이머
- setTimeout : 지정된 시간이 흐르면 함수 실행 
- setInterval : 일정한 시간 간격으로 함수를 반복 실행
*HTML 요소를 동적으로 읽고 쓰기
# Document 객체 : 웹 페이지 그 자체. 웹 페이지에 존재하는 HTML 요소에 접근하고자 할 때는 반드시 Document 객체부터 시작해야 한다. 
# Document 메소드 
- HTML 요소 선택 : document.getElementById(아이디) -- 해당 아이디의 요소를 선택.
*Canvas 의 기본 좌표계 : 왼쪽 윗부분이 원점, 오른쪽이 x축 정방향, 아래쪽이 y축 정방향.
                          (변경 가능)
*Canvas에서 사각형 그리기 [x,y = 사각형 왼쪽 위 끝점(x,y)]
- 테두리 그리기 : strokeRect(x,y,width,height)
- 사각형 채우기 : fillRect(x,y,width,height)
- 사각형 지우기 : clearRect(x,y,width,height)
*패스로 그리기 
- 펜 이동 : ctx.moveTo(x,y)
- 선으로 연결 : ctx.lineTo(x,y)
- 원호 그리기 : arc(x,y,radius,startAngle,endAngle,anticlockwise)
		(x,y) : 원의 중심
		radius : 반지름
		startAngle, endAngle : 시작 각도, 끝 각도
		anticlockwise : true = 시계 반대, false = 시계 
*선 색상 설정 : ctx.strokeStyle = “색상”;
*채우기 색상 설정 : ctx.fillStyle = “색상”;
*투명도 설정 : ctx.globalAlpha = “0부터 1까지”;
*선 두께 설정 : ctx.lineWidth = “양의정수”;
*패스 종단점 모양 설정 : lineCap 프로퍼티 1)butt 2)square 3)round
*패스 정점의 설정 : lineJoin 프로퍼티 1)miter 2)round 3)bevel

<7장>
*자바스크립트의 제어구문
- 조건문
- 반복문
- 점프문
*조건문
- if/else문
1) if (조건식) 문장
2) if (조건식) 문장1 else 문장2
*switch문
: switch의 표현식을 평가한 값과 일치하는 case의 라벨 값을 찾아 해당 case의 실행문을 실행한다. 일반적으로 case 라벨의 실행문 끝에 break;를 써준다. 
*반복문 
- while문 
: while (조건식) 문장 
# console.log를 사용해서 반복문 안의 변수값을 추적하면 프로그램의 동작을 확인하거나 디버깅 할 수 있다. 
- do/while문
: do 문장 while(조건식); -- while문과 달리 문장을 먼저 실행한 뒤 조건식을 평가한다. 만약 조건식이 false이면 do/while문을 빠져나오고 조건식이 true이면 시작부분으로 다시 돌아간다. 

- for문
: for(초기화식; 조건식; 반복식) 문장 
- for/in문
: for (변수 in 객체 표현식) 문장 — 객체 표현식이 null이나 undefined가 아니면 객체의 프로퍼티의 이름이 변수에 할당되고 문장이 실행된다. 
*점프문
- 라벨문 
: 라벨 이름 : 문장 — 라벨 이름으로는 모든 식별자를 사용할 수 있다. 라벨을 사용할 수 있는 문장은 switch문과 반복문 뿐이다. [break문-switch문,반복문/continue문-반복문]
- break문
: 점프할 라벨 지정 – break 라벨 이름;
라벨을 지정한 break문은 중첩된 반복문의 안쪽 반복문에서 전체 반복문을 빠져나올 때 사용한다. 
- continue문 
: 점프할 라벨 지정 – continue 라벨 이름;
break문과 달리 라벨 지정 여부와 상관없이 반복문에서 사용할 수 있다. continue문이 실행되면 반복문을 멈추고 반복을 새로 시작한다. 이때,
1) while문 : 조건식을 평가한 후 true면 처음부터 실행. 
2) do/while문 : 반복문의 마지막 조건식을 평가한 후 true면 처음부터 실행.
3) for문 : 반복식을 실행하고 조건식을 평가한 뒤 true이면 이어서 실행.
4) for/in문 : 반복문의 처음으로 돌아가서 변수에 할당되어있는 프로퍼티의 다음 프로퍼티를 대상으로 반복문 실행.